{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started with Python-powered OpenSCAD Enabling Python support For Python support to be enabled, 2 conditions must be met: The python-engine feature must be enabled The extension of the file you're editing MUST be .py . If both those condition are met, then the file will be interpreted as a Python file. Differences with regular OpenSCAD If you're familiar with regular OpenSCAD, then the synthax will be fairly obvious, as the names of functions and classes are the same. The major difference is that you need to use the output() function for a shape to be displayed, as opposed to it being displayed automatically in regular OpenSCAD. Creating a basic shape Lets create a 5x5x5 cube. # Create the cube object, and store it in variable \"c\" c = cube(5) # Or, more explicitely # c = cube([5,5,5]) # Display the cube output(c) That was pretty easy! Next, let's see how to combine multiple shapes .","title":"Getting Started"},{"location":"#getting-started-with-python-powered-openscad","text":"","title":"Getting started with Python-powered OpenSCAD"},{"location":"#enabling-python-support","text":"For Python support to be enabled, 2 conditions must be met: The python-engine feature must be enabled The extension of the file you're editing MUST be .py . If both those condition are met, then the file will be interpreted as a Python file.","title":"Enabling Python support"},{"location":"#differences-with-regular-openscad","text":"If you're familiar with regular OpenSCAD, then the synthax will be fairly obvious, as the names of functions and classes are the same. The major difference is that you need to use the output() function for a shape to be displayed, as opposed to it being displayed automatically in regular OpenSCAD.","title":"Differences with regular OpenSCAD"},{"location":"#creating-a-basic-shape","text":"Lets create a 5x5x5 cube. # Create the cube object, and store it in variable \"c\" c = cube(5) # Or, more explicitely # c = cube([5,5,5]) # Display the cube output(c) That was pretty easy! Next, let's see how to combine multiple shapes .","title":"Creating a basic shape"},{"location":"combining_objects/","text":"Combining objects Displaying multiple shapes (union) If you tried calling output a second time, you will have noticed that is overwrites the previous call. For example: # Create a cube and a cylinder cu = cube([5,5,5]) cy = cylinder(5) # We display the cube output(cu) # We display the cylinder, which overwrites the previous output call # THE CUBE IS NO LONGER DISPLAYED output(cy) So how do we display multiple shapes? Simple! You combine them with the union() method. # Create a cube and a cylinder cu = cube([5,5,5]) cy = cylinder(5) # Create a third object that is a fusion of the cube and the cylinder fusion = cu.union(cy) # alternatively you can also write: # fusion = union([cu, cy, more_objects]) # Both objects are now displayed at once output(fusion) # or: # output( [cu,cy] ) # or use python to incrementally create the array ... One important thing to note is the fact the union() does NOT edit the objects in place. Rather, it creates a third brand new object. This means that: You must assign the union to a variable, just calling cu.union(cy) alone will have no effects on cu or cy . You keep access to the originals objects. For example, you could still display just the cube by using output(cu) Substracting shapes (difference) You learned how to merge two objects into one, but what if you want to exclude an object from another? For that, you can use the difference() method: # Create a cube and a cylinder that overlap cu = cube([5,5,5], center = True) cy = cylinder(15, center = True) # Substract the cylinder from the cube diff = cu.difference(cy) # Display the result output(diff) As you can see, this creates a cylinder-shaped hole in the cube! Using operators Using the union and difference method works great, but is a little heavy synthax-wise. You can instead simplify it by using operators ! Here is a table detailing which operator matches each method: Operator Method + union - difference * intersection So, reusing our earlier examples, you could write cu = cube([5,5,5]) cy = cylinder(5) # Replaces cu.union(cy) fusion = cu + cy output(fusion) Now that we know how to combine objects, lets see how we can position them .","title":"Combining Objects"},{"location":"combining_objects/#combining-objects","text":"","title":"Combining objects"},{"location":"combining_objects/#displaying-multiple-shapes-union","text":"If you tried calling output a second time, you will have noticed that is overwrites the previous call. For example: # Create a cube and a cylinder cu = cube([5,5,5]) cy = cylinder(5) # We display the cube output(cu) # We display the cylinder, which overwrites the previous output call # THE CUBE IS NO LONGER DISPLAYED output(cy) So how do we display multiple shapes? Simple! You combine them with the union() method. # Create a cube and a cylinder cu = cube([5,5,5]) cy = cylinder(5) # Create a third object that is a fusion of the cube and the cylinder fusion = cu.union(cy) # alternatively you can also write: # fusion = union([cu, cy, more_objects]) # Both objects are now displayed at once output(fusion) # or: # output( [cu,cy] ) # or use python to incrementally create the array ... One important thing to note is the fact the union() does NOT edit the objects in place. Rather, it creates a third brand new object. This means that: You must assign the union to a variable, just calling cu.union(cy) alone will have no effects on cu or cy . You keep access to the originals objects. For example, you could still display just the cube by using output(cu)","title":"Displaying multiple shapes (union)"},{"location":"combining_objects/#substracting-shapes-difference","text":"You learned how to merge two objects into one, but what if you want to exclude an object from another? For that, you can use the difference() method: # Create a cube and a cylinder that overlap cu = cube([5,5,5], center = True) cy = cylinder(15, center = True) # Substract the cylinder from the cube diff = cu.difference(cy) # Display the result output(diff) As you can see, this creates a cylinder-shaped hole in the cube!","title":"Substracting shapes (difference)"},{"location":"combining_objects/#using-operators","text":"Using the union and difference method works great, but is a little heavy synthax-wise. You can instead simplify it by using operators ! Here is a table detailing which operator matches each method: Operator Method + union - difference * intersection So, reusing our earlier examples, you could write cu = cube([5,5,5]) cy = cylinder(5) # Replaces cu.union(cy) fusion = cu + cy output(fusion) Now that we know how to combine objects, lets see how we can position them .","title":"Using operators"},{"location":"positioning_objects/","text":"Positioning objects To move an object, you can simply use the translate() method: # Create two cubes c1 = cube([5,5,5]) c2 = cube([3,3,10]) # Translate the cube by 7 units up c2 = c2.translate([0,0,7]) # Display the result result = c1 + c2 output(result) Notice how we assign the result of the translate() method back into c2. This is because just like the union() and difference() methods we saw earlier, this method return a brand new object.","title":"Positioning Objects"},{"location":"positioning_objects/#positioning-objects","text":"To move an object, you can simply use the translate() method: # Create two cubes c1 = cube([5,5,5]) c2 = cube([3,3,10]) # Translate the cube by 7 units up c2 = c2.translate([0,0,7]) # Display the result result = c1 + c2 output(result) Notice how we assign the result of the translate() method back into c2. This is because just like the union() and difference() methods we saw earlier, this method return a brand new object.","title":"Positioning objects"}]}